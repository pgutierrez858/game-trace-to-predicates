package predcompiler.compilation.grammarevolution

import org.moeaframework.core.Solution
import org.moeaframework.core.variable.Grammar
import org.moeaframework.problem.AbstractProblem
import org.moeaframework.util.grammar.ContextFreeGrammar
import predcompiler.compilation.evaluation.IPredicateEvaluator
import predcompiler.compilation.evaluation.RealValuation
import kotlin.random.Random

/**
 * The symbolic regression problem for grammatical evolution. Given a function,
 * the symbolic regression problem attempts to find an expression for closely
 * approximating the output of the function.
 */
class GrammarRegression
/**
 * Constructs a grammar regression problem to infer a temporal predicate that
 * tries to fit the traces given as positive examples and reject those shown as
 * counter examples.
 */
    (
    /**
     * Demonstrations of good behavior (positive examples)
     */
    private val examples: List<Array<RealValuation>>,
    /**
     * Demonstrations of bad behavior to avoid (negative examples)
     */
    private val counterExamples: List<Array<RealValuation>>,
    /**
     * The grammar.
     */
    private val grammar: ContextFreeGrammar,
    /**
     * Evaluator for computing a predicate's fitness.
     */
    private val evaluator: IPredicateEvaluator
) : AbstractProblem(1, 1) {
    /**
     * The length of the codon.
     */
    private val codonLength = 20

    /**
     * Converts the solution into a program.
     *
     * @param solution the solution
     * @return the predicate generated by the solution
     */
    fun getPredicate(solution: Solution): String? {
        val codon = (solution.getVariable(0) as Grammar).toArray()
        return grammar.build(codon)
    } // getPredicate

    override fun evaluate(solution: Solution) {
        // derive the predicate using the codon
        val predicate = getPredicate(solution)

        if (predicate == null) {
            // the codon did not produce a valid grammar; penalize the solution
            solution.setObjective(0, Double.POSITIVE_INFINITY)
        } else {
            val fitness = evaluator.evaluatePredicate(predicate, examples, counterExamples)
            solution.setObjective(0, -fitness.toDouble())
        }
    } // evaluate

    override fun newSolution(): Solution {
        val solution = Solution(1, 1)
        solution.setVariable(0, Grammar(Random.nextInt(2, codonLength + 1)))
        return solution
    } // newSolution

} // GrammarRegression
