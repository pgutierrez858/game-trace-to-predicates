package predcompiler.compilation.grammarevolution;

import java.io.IOException;
import java.util.List;

import org.moeaframework.core.Solution;
import org.moeaframework.core.variable.Grammar;
import org.moeaframework.problem.AbstractProblem;
import org.moeaframework.util.grammar.ContextFreeGrammar;
import predcompiler.compilation.evaluation.IPredicateEvaluator;
import predcompiler.compilation.evaluation.RealValuation;

/**
 * The symbolic regression problem for grammatical evolution. Given a function,
 * the symbolic regression problem attempts to find an expression for closely
 * approximating the output of the function.
 */
public class GrammarRegression extends AbstractProblem {

	/**
	 * Demonstrations of good behavior (positive examples)
	 */
	private final List<RealValuation[]> examples;

	/**
	 * Demonstrations of bad behavior to avoid (negative examples)
	 */
	private final List<RealValuation[]> counterExamples;

	/**
	 * The length of the codon.
	 */
	private int codonLength;

	/**
	 * The grammar.
	 */
	private ContextFreeGrammar grammar;

	/**
	 * Evaluator for computing a predicate's fitness.
	 */
	private IPredicateEvaluator evaluator;

	/**
	 * Constructs a grammar regression problem to infer a temporal predicate that
	 * tries to fit the traces given as positive examples and reject those shown as
	 * counter examples.
	 */
	public GrammarRegression(List<RealValuation[]> examples, List<RealValuation[]> counterExamples,
			ContextFreeGrammar grammar, IPredicateEvaluator evaluator) throws IOException {
		super(1, 1);
		this.examples = examples;
		this.counterExamples = counterExamples;
		this.grammar = grammar;
		this.evaluator = evaluator;

		codonLength = 20;
	} // GrammarRegression

	/**
	 * Converts the solution into a program.
	 * 
	 * @param solution the solution
	 * @return the predicate generated by the solution
	 */
	public String getPredicate(Solution solution) {
		int[] codon = ((Grammar) solution.getVariable(0)).toArray();
		return grammar.build(codon);
	} // getPredicate

	@Override
	public void evaluate(Solution solution) {
		// derive the predicate using the codon
		String predicate = getPredicate(solution);

		if (predicate == null) {
			// the codon did not produce a valid grammar; penalize the solution
			solution.setObjective(0, Double.POSITIVE_INFINITY);
		} else {

			float fitness = evaluator.evaluatePredicate(predicate, examples, counterExamples);
			solution.setObjective(0, -fitness);
		}
	} // evaluate

	@Override
	public Solution newSolution() {
		Solution solution = new Solution(1, 1);
		solution.setVariable(0, new Grammar(getRandomNumber(2, codonLength)));
		return solution;
	} // newSolution

	public int getRandomNumber(int min, int max) {
		return (int) ((Math.random() * (max - min)) + min);
	} // getRandomNumber

} // GrammarRegression